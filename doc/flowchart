Basic Imogen operational flowchart:

./imogen serial runfile n
	-> invokes matlab -r parImogenLoad(runfile, ...)
./imogen parallel runfile n NP
	-> invokes mpirun -np NP matlab -r parImogenLoad(runfile, ...)
./imogen cluster runfile n nodes ppn NP
	-> Submits the above to batch processor

parImogenLoad:
	-> Calls MPI_Init()
	-> Initializes GPUs
	-> Attempts eval(runfile)
	-> Calls MPI_Finalize()
	-> Imogen exits

[ At this point we have all Imogen paths in the Matlab search path. We have
  access to the GPU through the GPU_Type, MPI through mpi_ wrapper functions,
  and low-level access to our parallel subsystem through GIS' data fields.

  We do NOT have a directory to save things to, we do NOT have any Imogen file
  logger stuff so fprintf() has to suffice ]

runfile:
	-> Calls starterRun()
	-> Must call
		GIS = GlobalIndexSemantics()
		GIS.setup([nx ny nz])
	   to setup parallel array system with global array size [nx ny nz]
	-> Creates an Initializer
	-> Sets initial parameters on Initializer
	-> Requests initial parameters be stored to tmp file
	-> Invokes imogen() with filename



runfile if resuming:
	-> See special_Resume.m	
	-> Calls starterRun()
	-> Provides information to adulterate original max steps, etc.
	-> Invokes imogen() with path to original sim's init
	   and restart information

imogen():
	-> Loads initial conditions file
	-> Creates run manager
    [* We now have run.save.logPrint available *]
	-> Initializes results path
		-> If new run, creates unique new path
		-> If resuming, sets up original paths
	-> If new run:
		-> Creates fluid fields using IC data
	-> If restarting:
		-> Loads indicated dataframe
		-> Sets up global index semantics with original resolution
		-> Recreates fluid fields using frame's data
	-> Initializes self-gravity system
	-> Initializes arbitrary external gravity field
	-> Saves IC data struct (minus fluid fields) to SimInitializer_rank#.mat
	-> Clears IC structure from host memory
	-> Calls run.initialize() to run final pre-start checks
    -----> Enters fluid dynamic loop

Fluid dynamic loop:
	-> Calculates CFL-limited timestep
		* Does not include gravitational, radiative, or any other
		  transport-stiffness related constraints
		* Thus implicitly assuming that fluid/sound speeds are the
                  limiting factor
	-> Perform forward flux sweep (fluid and B)
	-> Applies source/sink functions
	-> Perform reverse order flux sweep, completing timestep
	-> Check whether to save data, images, etc
	-> Update outputs to logfile

Final stage:
	-> Print time spent running
?	-> Clear variables from GPUs
	-> Return to parImogenLoad()
