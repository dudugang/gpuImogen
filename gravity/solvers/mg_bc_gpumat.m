function phiSet = mg_bc_gpumat(rhos, poss, bvecSet, coarseConst, h)
% Calculate boundary conditions using multigrid summation
% This function is for generating _BOUNDARY CONDITIONS FOR
% A LINEAR SOLVER_ so it _ASSUMES REGULAR GRID SPACING_
%
%>> rhos         Cell array of mass generated by massQuantization()            cell
%>> poss         Cell array of position generated by massQuantization()        cell
%>> bvec         [9x1] double describing where to sum at                       double
%>> coarseConst  Constant for tuning accuracy vs speed                         double
%<< phi          Computed potential array                                      double

%--- Step one: Pull bvec apart and initialize ---%
%        This is using the 'bvec' argument meant for mg_bc for dropin compatibility for now
%        This pulls it apart and generates a set of points we're looking to generate conditions for

phiSet = cell(size(bvecSet));

for q = 1:numel(phiSet)
    bvec = bvecSet{q};

    x0 = bvec(1:3);
    xf = max(bvec(1:3)+1, bvec(4:6));
    nsteps = max(bvec(7:9)+1,1)-1;
    nsteps(nsteps == 0) = .1;

    xarr = x0(1):(xf(1)-x0(1))/nsteps(1):xf(1);
    yarr = x0(2):(xf(2)-x0(2))/nsteps(2):xf(2);
    zarr = x0(3):(xf(3)-x0(3))/nsteps(3):xf(3);

    [X Y Z] = ndgrid(xarr,yarr,zarr);
    W = 1:numel(X);

    pointArr = GPUdouble(zeros([3 numel(X)]));
    pointArr(3*W-2) = X(:);
    pointArr(3*W-1) = Y(:);
    pointArr(3*W-0) = Z(:);
    phi = zeros([1 numel(X)], GPUdouble);

    mgbc_gpukern(rhos, poss, pointArr, phi, coarseConst, h);
    
    phiSet{q} = reshape(1.0*phi, bvecSet{q}(7:9)+1);
end

end


