function test_mpi_matlab(rez)

if nargin < 1
    rez = [32 32 32];
    disp('Defaulting to resolution of 32^3');
end

context = parallel_start();
topology = parallel_topology(context, 3);
pg = ParallelGlobals(context, topology); % yucky global from hell

MYID = context.rank;

geometry = GeometryManager(rez);

if MYID == 0; fprintf('TESTING SEND/RECV ------------\n'); end

for vartype=1:9
    rng(0);
    typestr = MPI_Syms.typename(vartype);
        
    succeed = 0;
    if context.rank == 0
        v = maketype(rand([1024 1]), vartype);

        for Q = 1:(context.size-1); mpi_send(v, Q); end
    else
        v = mpi_recv(vartype, 0);
        vtrue = maketype(rand([1024 1]), vartype);

        if v ~= vtrue; succeed = 1; end            
    end
    fail = mpi_any(succeed);
    if (MYID==0);
        if fail; fprintf('    Tested MPI_Send/MPI_Recv of %s; Result: FAILURE!\n', typestr); else; fprintf('    Tested MPI_Send/MPI_Recv of %s; Result: Success.\n', typestr); end
    end

end

mpi_barrier();

if MYID == 0; fprintf('TESTING REDUCTION FUNCTIONS ------------\n'); end
rng(MYID); res = 6;
alpha = rand(res);
beta  = single(alpha);
gamma = int32(round(alpha));

testerfunc = @(y, a, b, c) any(y(:) - a(:)) | any(y(:) - b(:)) | any(int32(y(:)) - c(:));

funcpairs = cell([7 3]);
funcpairs(1,:) = { @(x) mpi_all(round(x)), @(u, v) round(u) .* round(v), 'MPI_LAND'};
funcpairs(2,:) = { @(x) mpi_any(round(x)), @(u, v) round(u) + round(v), 'MPI_LOR'};
funcpairs(3,:) = { @ mpi_max, @(u, v) max(u, v), 'MPI_MAX'};
funcpairs(4,:) = { @ mpi_min, @(u, v) min(u, v), 'MPI_MIN'};
funcpairs(5,:) = { @(x) mpi_allgather(x(:)), @(u, v) [u(:); v(:)], 'MPI_ALLGATHER'};
funcpairs(6,:) = { @ mpi_prod, @(u, v) u .* v, 'MPI_PROD'};
funcpairs(7,:) = { @ mpi_sum, @(u, v) u + v, 'MPI_SUM'};


for theta = 1:7;
    A = funcpairs{theta,1}(alpha);
    B = funcpairs{theta,1}(beta);
    C = funcpairs{theta,1}(gamma);

    if MYID == 0
        rng(0);
        trueans = rand(res);
        for n = 2:context.size
            rng(n-1);
            trueans = funcpairs{theta,2}(trueans , rand(res));
        end
        
        if theta < 3;
            trueans = (trueans ~= 0);
            fail = testerfunc(trueans, A, B, C);
        else
            if theta < 6
                fail = any(trueans(:) - A(:)) | any(abs(trueans(:) - B(:)) > 1e-6) | any(int32(trueans(:)) - C(:));
            else
                fail = any(trueans(:) - A(:)) | any(abs(trueans(:) - B(:)) > 1e-6);
            end
        end
        if fail; fprintf('    Tested %14s; Result: FAILURE!\n', funcpairs{theta, 3}); else fprintf('    Tested %14s; Result: Success.\n', funcpairs{theta, 3}); end
    end

end

mpi_barrier();

mpi_deleteDimcomm(geometry.topology);

mpi_barrier();

if context.size > 1
    mpi_finalize();
end

end

function y = maketype(x, t)
% Assuming 'x' was generated by rand(...), converts it into a full-range variable of type MPI_Syms.*
% i.e. floats stay float, uint32 is round(x*4 billion), int16 is 32767*(x-.5), etc

switch(t) 
    case MPI_Syms.ML_MPIDOUBLE; y = x;
    case MPI_Syms.ML_MPISINGLE; y = single(x);
    case MPI_Syms.ML_MPIUINT16; y = uint16(round(65535 * x));
    case MPI_Syms.ML_MPIINT16;  y = int16(round(32767*(x-.5)));
    case MPI_Syms.ML_MPIUINT32; y = uint32(round(4294967295*x));
    case MPI_Syms.ML_MPIINT32;  y = int32(round(2147483647*(x-.5)));
    case MPI_Syms.ML_MPIUINT64; y = uint64(round(4294967295*x));
    case MPI_Syms.ML_MPIINT64;  y = int64(round(2147483647*(x-.5)));
    case MPI_Syms.ML_MPICHAR;   y = char(65 + round(64*x));
end

end
